package gg.hcfactions.cx.modules.player.exploit;

import com.google.common.collect.Sets;
import gg.hcfactions.cx.CXService;
import gg.hcfactions.cx.modules.ICXModule;
import gg.hcfactions.libs.bukkit.scheduler.Scheduler;
import lombok.Getter;
import lombok.Setter;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.player.PlayerInteractAtEntityEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.potion.PotionEffectType;

import java.util.Set;
import java.util.UUID;

public final class ExploitPatchModule implements ICXModule, Listener {
    @Getter public final CXService service;
    @Getter public final String key;
    @Getter @Setter public boolean enabled;

    private boolean disableBlockGlitching;
    private final Set<UUID> recentlyBrokeBlock;

    private boolean disablePearlClipping;

    public ExploitPatchModule(CXService service) {
        this.service = service;
        this.key = "exploit.";
        this.recentlyBrokeBlock = Sets.newConcurrentHashSet();
    }

    @Override
    public void onEnable() {
        loadConfig();

        if (!isEnabled()) {
            return;
        }

        getPlugin().registerListener(this);
    }

    @Override
    public void onDisable() {
        if (recentlyBrokeBlock != null) {
            recentlyBrokeBlock.clear();
        }
    }

    @Override
    public void onReload() {
        loadConfig();
    }

    private void loadConfig() {
        final YamlConfiguration conf = getPlugin().loadConfiguration("commandx");

        enabled = conf.getBoolean(key + "enabled");
        disableBlockGlitching = conf.getBoolean(key + "disable_block_glitching");
        disablePearlClipping = conf.getBoolean(key + "disable_pearl_clipping");
    }

    /**
     * Block glitch prevention
     * @param event BlockBreakEvent
     */
    @EventHandler (priority = EventPriority.MONITOR)
    public void onBlockBreak(BlockBreakEvent event) {
        if (!disableBlockGlitching) {
            return;
        }

        final Player player = event.getPlayer();

        if (recentlyBrokeBlock.contains(player.getUniqueId())) {
            return;
        }

        if (!event.isCancelled()) {
            return;
        }

        if (!event.getBlock().getType().isBlock()) {
            return;
        }

        // TODO: Move this to an ImmutableList up top?
        if (event.getBlock().getType().equals(Material.SHORT_GRASS)
            || event.getBlock().getType().equals(Material.TALL_GRASS)
            || event.getBlock().getType().equals(Material.ROSE_BUSH)
            || event.getBlock().getType().equals(Material.SUNFLOWER)
            || event.getBlock().getType().equals(Material.PEONY)
            || event.getBlock().getType().equals(Material.SUGAR_CANE)
            || event.getBlock().getType().equals(Material.LILAC)
            || event.getBlock().getType().name().endsWith("_PLANT")) {
            return;
        }

        recentlyBrokeBlock.add(player.getUniqueId());
        new Scheduler(getPlugin()).sync(() -> recentlyBrokeBlock.remove(player.getUniqueId())).delay(5L).run();
    }

    /**
     * Block glitch prevention
     * @param event PlayerInteractAtEntityEvent
     */
    @EventHandler
    public void onPlayerInteractAtEntity(PlayerInteractAtEntityEvent event) {
        final Player player = event.getPlayer();

        if (recentlyBrokeBlock.contains(player.getUniqueId())) {
            player.sendMessage(ChatColor.RED + "Please do not block-glitch");
            event.setCancelled(true);
        }
    }

    /**
     * Block glitch prevention
     * @param event PlayerInteractEntityEvent
     */
    @EventHandler
    public void onPlayerInteractEntity(PlayerInteractEntityEvent event) {
        final Player player = event.getPlayer();

        if (recentlyBrokeBlock.contains(player.getUniqueId())) {
            player.sendMessage(ChatColor.RED + "Please do not block-glitch");
            event.setCancelled(true);
        }
    }

    /**
     * Block glitch prevention
     * @param event EntityDamageByEntityEvent
     */
    @EventHandler
    public void onEntityAttackEntity(EntityDamageByEntityEvent event) {
        if (!(event.getDamager() instanceof final Player player)) {
            return;
        }

        if (recentlyBrokeBlock.contains(player.getUniqueId())) {
            player.sendMessage(ChatColor.RED + "Please do not block-glitch");
            event.setCancelled(true);
        }
    }

    @EventHandler
    public void onPlayerInteract(PlayerInteractEvent event) {
        if (!isEnabled() || !disablePearlClipping) {
            return;
        }

        final Player player = event.getPlayer();
        final Action action = event.getAction();
        final ItemStack item = event.getItem();

        if (item == null || !item.getType().equals(Material.ENDER_PEARL)) {
            return;
        }

        if (action.equals(Action.RIGHT_CLICK_AIR)) {
            return;
        }

        final Block clickedBlock = event.getClickedBlock();

        if (clickedBlock != null && clickedBlock.getLocation().distance(player.getLocation()) < 3.0) {
            event.setCancelled(true);
            return;
        }

        if (clickedBlock == null || !(
                clickedBlock.getType().equals(Material.STRING) ||
                clickedBlock.getType().name().contains("FENCE") ||
                clickedBlock.getType().name().contains("PANE") ||
                clickedBlock.getType().name().contains("GLASS_PANE") ||
                clickedBlock.getType().name().contains("_WALL") ||
                clickedBlock.getType().name().contains("FENCE_GATE"))) {
            return;
        }

        event.setCancelled(true);
    }

    @EventHandler
    public void onPlayerTeleport(PlayerTeleportEvent event) {
        if (!isEnabled() || !disablePearlClipping) {
            return;
        }

        if (!event.getCause().equals(PlayerTeleportEvent.TeleportCause.ENDER_PEARL)) {
            return;
        }

        if (event.getTo() == null) {
            return;
        }

        final Player player = event.getPlayer();
        final Material toMat = event.getTo().getBlock().getType();

        if (toMat.name().endsWith("_DOOR") || toMat.name().endsWith("_GATE")) {
            player.getInventory().addItem(new ItemStack(Material.ENDER_PEARL, 1));
            player.sendMessage(ChatColor.RED + "Invalid Pearl Location");
            event.setCancelled(true);
            return;
        }

        if (event.getTo().getBlock().getType().isBlock()) {
            final double x = event.getTo().getBlockX() + 0.5;
            final double z = event.getTo().getBlockZ() + 0.5;
            final float yaw = event.getTo().getYaw();
            final float pitch = event.getTo().getPitch();
            final double y = (player.hasPotionEffect(PotionEffectType.LEVITATION) && event.getTo().getY() >= event.getFrom().getY()) ? event.getTo().getBlockY() - 1.0 : event.getTo().getBlockY();
            final World world = event.getTo().getWorld();

            event.setTo(new Location(world, x, y, z, yaw, pitch));
        }
    }
}
